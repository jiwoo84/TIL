# 자료구조

# 1. 자료구조가 중요한 까닭

## 배열의 연산

배열: 가장 기본적인 자료구조  ex) [ 12, 2, 7, 6, ...]

- **읽기**
    
    자료 구조 내 특정 위치를 찾는 것  ex) 인덱스 2의 값 찾기
    
    - 배열 읽기는 한 단계 만에 끝나는 효율적인 연산
        
        (컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있기 때문)
        
- **검색**
    
    자료 구조 내 특정 값을 찾는 것  ex) “jiwoo”라는 값이 있는지, 어떤 인덱스에 있는지
    
    - 선형 검색, 이진 검색 등 다양한 방법 존재
    
- **삽입**
    
    자료 구조에 새로운 값 추가
    
    - 최적: 맨 끝에 추가 ⇒ 1단계
    - 최악: 맨 앞에 추가 (한 칸씩 뒤로 밀고 → 추가) ⇒ **N+1 단계**
        
        
- **삭제**
    
    자료 구조에서 값 제거
    
    - 최적: 맨 뒤 값 삭제 ⇒ 1단계
    - 최악: 맨 앞 값 삭제 (빈 공간 허용하지 않으므로 앞으로 이동) ⇒ **N 단계**
    

## 집합의 연산

집합: 중복값을 허용하지 않는 자료구조

(아래 연산은 배열 기반 집합으로 분석)

- 읽기, 검색: 일반 배열과 같음
- 삽입 : 검색 우선 (값이 이미 집합에 있는지) → 삽입
    - 최선: 검색 (앞에서부터 하나씩/ N단계) → 맨 뒤에 삽입(1단계) ⇒ **N+1 단계**
    - 최악: 검색 (앞에서부터 하나씩/ N단계) → 모든 값 오른쪽으로 옮김(N) → 삽입 ⇒ **2N+1 단계**

## 마무리

자료구조의 성능 측정(시간 복잡도 계산): 연산에 필요한 단계 수를 구하는 것

∴ 프로그램의 속도에는 자료구조부터 잘 세우는 것이 중요하다

- 정렬된 배열의 검색
    
    선형 탐색보다 이진 탐색이 효율적
    
- 빅 오 (효율적인 순서)
    - O(1) = 데이터 갯수에 상관없이 단계수가 일정
    - O(log**²**) = 데이터가 두 배로 증가할 때마다 한 단계씩 늘어남 (로그 시간)
    - O(N) = N개의 원소가 있을 때 N단계가 걸림

## 버블정렬

왼쪽부터 두 개씩 비교해서 작은 값 → 왼쪽, 큰 값 → 오른쪽으로 바꾸기

한 줄 비교할 때마다 맨 뒤에 제일 큰 값이 가게 된다

```jsx
let bubbleSort = function(array) {
	for(let i = 0; i < array.length; i++) {
		for(let j = 0; j < array.length -1 -i; j++ {
			if(array[j] > array[j+1]) {
				let temp = array[j];
				array[j] = array[j+1];
				array[j+1] = temp;
				// [array[j], array[j+1] = [array[j+1], array[j]];
			}
		}
	}
	return array;
};
```

- 효율성
    
    비교 N(N+1)/2 + 교환  N(N+1)/2 = N(N+1) 
    
    ⇒ **O(N²)** 
    
    - 이차시간이라고 부르며 비효율적
    - 중첩루프를 사용하는 알고리즘의 효율성
    

## 선택정렬

오른쪽으로 비교하면서 제일 작은 값 저장 → 맨 왼쪽 값과 교환 → 반복

```jsx
function selectionSort(array) {
	for(let i = 0; i < array.length; i++) {
		let lowestNumberIndex = i;
		for(let j = i + 1; j < array.length; j++) {
			if(array[j] < array[lowestNumberIndex]) {
				lowestNumberIndex = j;
			}
		}
		if(lowestNumberIndex !== i) {
			let temp = array[i];
			array[i] = array[lowestNumberIndex];
			array[lowestNumberIndex] = temp;
		}
	}
	return array;
};
```

- 효율성 : **O(N²)** (정확히는 O(N²/2))
    - 같은 **O(N²) 알고리즘이라면 비교해서 빠른거 써야겠지만 아니라면 비교할 필요 없음**
        
        ex) **O(N²) vs O(N²/2) ⇒  O(N²/2) 사용할 것**
        
        **O(N²) vs** O(100log**²**) ⇒ 
        

## 삽입정렬

인덱스 1의 값을 임시 변수에 저장 후, 비운다 → 공백 왼쪽의 값과 임시 변수의 값 비교해서, 왼쪽의 값이 더 크면 빈칸으로(오른쪽으로 한 칸)이동 → 임시 변수는 인덱스 0에 저장 → 인덱스 2의 값 임시 변수에 저장 후, 비운다 → 반복

```jsx
var insertionSort = function(array) {
  var i = 1, j, temp;
  for (i; i < array.length; i++) {
    temp7 = array[i]; // 새로운 숫자를 선택함
    for (j = i - 1; j >= 0 && temp < array[j]; j--) { // 선택한 숫자를 이미 정렬된 숫자들과 비교하며 넣을 위치를 찾는 과정, 선택한 숫자가 정렬된 숫자보다 작으면
      array[j + 1] = array[j]; // 한 칸씩 뒤로 밀어낸다
    }
    array[j + 1] = temp; // 마지막 빈 칸에 선택한 숫자를 넣어준다.
  }
  return array;
};
insertionSort([5, 6, 1, 2, 4, 3]); // [1, 2, 3, 4, 5, 6]
```

- 효율성: **O(N²)**