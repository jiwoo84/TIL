# CS50

## 기본 상식

- 1 Byte = 8 비트 = 2^8(256)개의 서로 다른 바이트 존재
- 1 KB = 1000 Byte
- 1 MB = 1000 KB
- 1 GB = 1000 MB
- 1 TB = 1000 GB

- ASCII(아스키코드) : 문자를 숫자로 표현할 수 있도록 정해진 표준
    
    ![Untitled](CS50%20b2df4/Untitled.png)
    
    - 해당 숫자가 2진법으로 변환되어 컴퓨터에 표현됨
        
        ex) A = 65 = 1000001
        
    - Unicode라는 표준에서 더 많은 비트를 사용하여 다른 다양한 문자들도 지원 (이모티콘도)
    
- 그림, 영상, 음악 표현
    
    → 이들은 무수히 많은 픽셀이 모여서 만듬
    
    - 픽셀: 세 가지 색을 다른 비율로 조합한 것RGB(Red, Green, Blue) 방식으로 표현함
    
- 컴퓨터는 RAM이라는 물리적 저장장치를 갖고 있음
    
    유한한 크기의 비트만 저장 가능하기에 부정확한 결과 나올 수 있음
    

## **변수, 상수, 입출력**

- 정수: 딱 떨어지는 수
- 실수: 소수점이 붙은 수

- 변수: 변하는 수 (예: 나이)
    - 선언: `자료형 변수명 = 값;`
- 상수: 변하지 않는 수
    - 선언: `const 자료형 상수명 = 값;`
    

## C 기본 문법

```c
#include <stdio.h>

int main(void) { 명령어 }
```

- `\n`  줄바꿈
- `%` 나머지
- `&&` 그리고
- `||` 또는
- `//` 주석  `/* 문장 */`

## data type

- **bool** (1byte)
    
    불리언 표현
    
- **char** (1byte)
    
    문자  (ex) `'a'`, `'Z'`,`'?'` (작은 따옴표)
    
- **int** (4byte)
    
    정수 (ex) `5`, `28`, `-3`, `0` 
    
- **float** (4byte)
    
    부동소수점을 갖는 실수 (ex) `3.14`, `0.0`, `-28.56` 
    
- **long** (8byte)
    
    (더 큰) 정수 (40억 이상의 정수) 
    
- **double** (8byte)
    
    (더 큰) 실수
    
- **string**: 문자열 `“hi”` (큰 따옴표)
- **void**: 아무것도 없음

## variable

`data-type var-name = ~;`

C는 오래된 언어이기 때문에 변수 앞에 데이터타입을 명시해야함 (string, int)

## get 함수

`get_data-type("data 형식지정자”, var-name}`

사용자의 값을 받아 변수값에 저장

- get_char
- get_double
- get_float
- get_int
- get_long
- get_string

```c
get_int("Scores:  "); // Scores : 입력창
get_int("Scores: 
```

## printf (출력)

`printf("data 형식지정자”, var-name);`

- 출력 명령
- 콤마 뒤 값 순서대로 출력

## **형식 지정자**

printf 함수에서는 각 데이터 타입을 위한 형식 지정자를 사용함

- **%c** : char
- **%f** : float, double
    
    (%.소수점f : 원하는 소수점까지 반올림해서 출력)
    
- **%i** : int
- **%li** : long
- **%s** : string

```c
string answer = get_string("what's your name?");

printf("hello %s, answer);
printf("your name is %s, right?", answer);
```

## 함수

`출력형 fnc-name(입력형 var-name)` // 선언 (미리 함수 알려줌)

`명령문;`

`출력형 fnc-name(입력형 var-name) {명령문;}`  // 정의

- 입출력 없다면 void
    
    `void fnc-name(void) {명령문;}` 
    

- 예시
    - 입력값 있는 함수
        
        ```c
        void printA(int n)  // 선언 (숫자가 입력됨)
        
        int main(void) {
        	printA(2);
        }
        
        void printA(int n) {  // 정의 (출력 없음)
        	printf("%i", n);
        }
        ```
        
    
    - 반환값 있는 함수
        
        ```c
        int printInput(void);  // 선언 (입력값 없음)
        
        int main(void) {
        	int i = printInput();
        	printf("%i", i);  // 입력 숫자가 출력됨
        }
        
        int printInput(void) {  // 정의 (출력값 있고 int형)
        	int input;
        	scanf_s("%i", &input);
        	return input;  // 출력값 
        }
        
        ```
        

## 루프

- **while**
    
    `(선언) while(조건) {명령(증감);}`
    
    - bolean == true 면 무한 반복
    - 증감은 명령문 안이나 다음줄에 넣음
    
    ```c
    int i = 0;
    while(i < 5) {
    	printf("hello world");
    	i = i + 1; 
    }
    ```
    

- **for**
    
    `for (선언; 조건; 증감) {명령어;}`
    
    변수 선언 상태 → 조건 만족시, 명령어 실행 → 변수 증감 후, 조건에 대입 → 조건 만족 시, 명령 수행 (반복) → 조건 불만족 시, 빠져나옴
    
    ```c
    for(int i = 0; i<5; i++){
    	printf("hello world");
    }
    ```
    
- **do while**
    
    `do {명령} while (조건);`
    
    - 명령 실행 → 조건 만족시, 명령 재실행 → 반복
    - 무조건 1번은 실행
    
    ```c
    int i = 0;
    do {
    	printf("hello world");
    }
    while (i < 5);
    ```
    

- `int i = 0;`
    
    `i = i + 1`  ==  `i+= 1`  == `i++`
    
    셋 다 같은 의미
    
    - `++` / `--` (증감연산자)
        
        피연산자를 1씩 증가 혹은 1씩 감소시킬 때 사용
        
        - `++i` : i+1 먼저 실행
        - `i++` : 다음 줄로 넘어갈 때 i+1 실행
        
    - += (더하기 할당 연산자) : 오른쪽 피연산자의 값을 변수에 더한 결과를 다시 변수에 할당
        
        
- `=` : 할당 연산자 (변수에 값을 할당)
    
    `==` / `===` : 일치 연산자
    

## terminal

- `$` 은 입력 커서

- **컴파일 명령**
    
    `clang 파일명.확장자`  파일의 코드를 컴파일하라는 명령
    
    `clang -o 지정파일명 파일명.확장자`  지정 파일명으로 컴파일 파일 생성
    
- **다른 파일 불러와서 컴파일**
    
    
    - 코드창: 상단에 `#include <파일명.확장자>` 추가
    - terminal: `make 파일명`
        
        
        - data-type과 fnc에 대한 정보가 들어있는 파일 불러와야 명령어 실행 가능(수업에서는 cs50.h 파일)
        - 복잡한 버전
            
            `clang -o 지정파일명 파일명.확장자 -l참조할파일명`
            
            ex) `clang -o hello hello.c -lcs50`
            
    
- **프로그램 실행**
    
    `폴더/파일명.확장자`  파일의 프로그램 실행
    
    ex) `./a.out`  .(지금 있는 현재 폴더)  a.out(보통 자동으로 만들어지는 파일명)
    
- **현재 폴더or디렉토리의 파일 리스트**
    
    `ls` 
    
    * 붙으면 머신 코드
    
- **파일 삭제**
    
    `rm 파일명.확장자`  →  (질문) `rm: remove refular file ‘파일.확장자` → `y` 입력  → 삭제
    

![Untitled](CS50%20b2df4/Untitled%201.png)

- `cd`  (change directory) 작업 위치 변경
    
    `cd 폴더명` 지정 폴더로 이동
    
    `pwd`  현재 폴더 위치 알려줌
    
- **디버깅 시, 사용가능 코드** (cs50 에서 사용가능)
    
    
    - help50
        
        `help50 make 파일명`
        
        에러 내용 해석해줌
        
    - (cs50 IDE) debug50
        
        `debug50 파일명`
        
        오른쪽 패널을 통해 한 줄씩 코드 실행할 수 있음
        
        종료하려면 ctrl + c
        
    - check50
        
        `check50 cs50/problems/파일명`
        
        자동 검사 프로그램
        
    - style50
        
        `style50 파일명.확장자`
        
        코드가 심미적으로 잘 작성되었는지 검사
        

# 컴파일

make나 clang을 사용해서 프로그램을 실행할 때 거치는 단계

## 컴파일러

소스 코드를 머신 코드로 변환해주는 프로그램

- 소스 코드: 사용자가 직접 작성한 코드
- 머신 코드: 컴퓨터가 이해할 수 있는 이진수 코드

![Untitled](CS50%20b2df4/Untitled%202.png)

## 1. **전처리(Precompile)**

- 전처리기에 의해 수행
- # 으로 시작되는 C 소스 코드는 전처리기에게 컴파일 실행 전, 실행 사항 전달
    
    ex) `#include <stdio.h>` : stdio.h 파일의 내용이 #include 부분에 포함
    

## 2. **컴파일(Compile)**

C 코드를 어셈블리어(저수준 프로그래밍 언어)로 변환

## 3. **어셈블(Assemble)**

- 어셈블리 코드를 오브젝트 코드(이진코드)로 변환
- 어셈블러라는 프로그램이 수행

## 4. **링크(Link)**

- 프로그램이 (math.h나 cs50.h와 같은 라이브러리를 포함해) 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 거치는 단계
- 링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐줌

# 배열

## 선언

`자료형 array[n];`

값을 받아 배열에 저장 후, 평균 구하는 코드

```c
#include <cs50.h>
#include <stdio.h>

float average(int length, int array[]);

int main(void)
{
    // 사용자로부터 점수의 갯수 입력
    int n = get_int("Scores:  ");

    // 점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Score %i: ", i + 1);
    }

    // 평균 출력
    printf("Average: %.1f\n", average(n, scores));
}

//평균을 계산하는 함수
float average(int length, int array[])
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += array[i];
    }
    return (float) sum / (float) length;
}
```