# CS50

## 기본 상식

- 1 Byte = 8 비트 = 2^8(256)개의 서로 다른 바이트 존재
- 1 KB = 1000 Byte
- 1 MB = 1000 KB
- 1 GB = 1000 MB
- 1 TB = 1000 GB

- ASCII(아스키코드) : 문자를 숫자로 표현할 수 있도록 정해진 표준
    
    ![Untitled](CS50%20b2df4b505bd148b3aaba41411f2e9b5b/Untitled.png)
    
    - 해당 숫자가 2진법으로 변환되어 컴퓨터에 표현됨
        
        ex) A = 65 = 1000001
        
    - Unicode라는 표준에서 더 많은 비트를 사용하여 다른 다양한 문자들도 지원 (이모티콘도)
    
- 그림, 영상, 음악 표현
    
    → 이들은 무수히 많은 픽셀이 모여서 만듬
    
    - 픽셀: 세 가지 색을 다른 비율로 조합한 것RGB(Red, Green, Blue) 방식으로 표현함
    
- 컴퓨터는 RAM이라는 물리적 저장장치를 갖고 있음
    
    유한한 크기의 비트만 저장 가능하기에 부정확한 결과 나올 수 있음
    
- 16진법
    
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F
    
    - 16진수 수는 0x를 붙여 표기됨
    

## **변수, 상수, 입출력**

- 정수: 딱 떨어지는 수
- 실수: 소수점이 붙은 수

- 변수: 변하는 수 (예: 나이)
    - 선언: `자료형 변수명 = 값;`
- 상수: 변하지 않는 수
    - 선언: `const 자료형 상수명 = 값;`
    

## C 기본 문법

```c
#include <stdio.h>

int main(void) { 명령어 }
```

- 입력값 지정시
    
    ex) `int main(int argc, char *argv[])`
    
    - `argc` : main 함수가 받게 될 입력의 개수
    - `argv[]` : 위 입력이 포함되어 있는 배열
        
        (`argv[0]`은 기본적으로 프로그램의 이름이 저장)
        
    
    ```jsx
    #include <cs50.h>
    #include <stdio.h>
    
    int main(int argc, string argv[])
    {
        if (argc == 2)
        {
            printf("hello, %s\n", argv[1]);
        }
        else
        {
            printf("hello, world\n");
        }
    }
    ```
    
    실행시 `./파일명 david`처럼 명령행 인자를 추가 ⇒ `hello, David`가 출력 (argc 는 2, argv[1] 은 “David”가 되기 때문)
    
    - 전달하는 문자열은 공백 기준으로 갯수가 나눠진다
        
        ex) `./파일명 I love you` ⇒ argc = 4
        

- `\n`  줄바꿈
- `%` 나머지
- `&&` 그리고
- `||` 또는
- `//` 주석  `/* 문장 */`

## data type

- **bool** (1byte)
    
    불리언 표현
    
- **char** (1byte)
    
    문자  (ex) `'a'`, `'Z'`,`'?'` (작은 따옴표)
    
- **int** (4byte)
    
    정수 (ex) `5`, `28`, `-3`, `0` 
    
- **float** (4byte)
    
    부동소수점을 갖는 실수 (ex) `3.14`, `0.0`, `-28.56` 
    
- **long** (8byte)
    
    (더 큰) 정수 (40억 이상의 정수) 
    
- **double** (8byte)
    
    (더 큰) 실수
    
- **string**: 문자열 `“hi”` (큰 따옴표)
- **void**: 아무것도 없음

## variable

`data-type var-name = ~;`

C는 오래된 언어이기 때문에 변수 앞에 데이터타입을 명시해야함 (string, int)

## get 함수

`get_data-type("data 형식지정자”, var-name}`

사용자의 값을 받아 변수값에 저장

- get_char
- get_double
- get_float
- get_int
- get_long
- get_string

```c
get_int("Scores:  "); // Scores : 입력창
get_int("Scores: 
```

## printf (출력)

`printf("data 형식지정자”, var-name);`

- 출력 명령
- 콤마 뒤 값 순서대로 출력

## scantf

`scanf("data 형식지정자”, var-name)`

형식지정자에 맞는 값을 받아, 변수에 저장

## **형식 지정자**

printf 함수에서는 각 데이터 타입을 위한 형식 지정자를 사용함

- **%c** : char
- **%f** : float, double
    
    (%.소수점f : 원하는 소수점까지 반올림해서 출력)
    
- **%i** : int
- **%li** : long
- **%s** : string (선언은 불가하지만 형식 지정자는 있음)
- **%p** : pointer

```c
string answer = get_string("what's your name?");

printf("hello %s, answer);
printf("your name is %s, right?", answer);
```

## 함수

`출력형 fnc-name(입력형 var-name)` // 선언 (미리 함수 알려줌)

`명령문;`

`출력형 fnc-name(입력형 var-name) {명령문;}`  // 정의

- 입출력 없다면 void
    
    `void fnc-name(void) {명령문;}` 
    

- 예시
    - 입력값 있는 함수
        
        ```c
        void printA(int n)  // 선언 (숫자가 입력됨)
        
        int main(void) {
        	printA(2);
        }
        
        void printA(int n) {  // 정의 (출력 없음)
        	printf("%i", n);
        }
        ```
        
    
    - 반환값 있는 함수
        
        ```c
        int printInput(void);  // 선언 (입력값 없음)
        
        int main(void) {
        	int i = printInput();
        	printf("%i", i);  // 입력 숫자가 출력됨
        }
        
        int printInput(void) {  // 정의 (출력값 있고 int형)
        	int input;
        	scanf_s("%i", &input);
        	return input;  // 출력값 
        }
        
        ```
        

## 루프

- **while**
    
    `(선언) while(조건) {명령(증감);}`
    
    - bolean == true 면 무한 반복
    - 증감은 명령문 안이나 다음줄에 넣음
    
    ```c
    int i = 0;
    while(i < 5) {
    	printf("hello world");
    	i = i + 1; 
    }
    ```
    

- **for**
    
    `for (선언; 조건; 증감) {명령어;}`
    
    변수 선언 상태 → 조건 만족시, 명령어 실행 → 변수 증감 후, 조건에 대입 → 조건 만족 시, 명령 수행 (반복) → 조건 불만족 시, 빠져나옴
    
    ```c
    for(int i = 0; i<5; i++){
    	printf("hello world");
    }
    ```
    
- **do while**
    
    `do {명령} while (조건);`
    
    - 명령 실행 → 조건 만족시, 명령 재실행 → 반복
    - 무조건 1번은 실행
    
    ```c
    int i = 0;
    do {
    	printf("hello world");
    }
    while (i < 5);
    ```
    

- `int i = 0;`
    
    `i = i + 1`  ==  `i+= 1`  == `i++`
    
    셋 다 같은 의미
    
    - `++` / `--` (증감연산자)
        
        피연산자를 1씩 증가 혹은 1씩 감소시킬 때 사용
        
        - `++i` : i+1 먼저 실행
        - `i++` : 다음 줄로 넘어갈 때 i+1 실행
        
    - += (더하기 할당 연산자) : 오른쪽 피연산자의 값을 변수에 더한 결과를 다시 변수에 할당
        
        
- `=` : 할당 연산자 (변수에 값을 할당)
    
    `==` / `===` : 일치 연산자
    

## terminal

- `$` 은 입력 커서

- **컴파일 명령**
    
    `clang 파일명.확장자`  파일의 코드를 컴파일하라는 명령
    
    `clang -o 지정파일명 파일명.확장자`  지정 파일명으로 컴파일 파일 생성
    
- **다른 파일 불러와서 컴파일**
    
    
    - 코드창: 상단에 `#include <파일명.확장자>` 추가
    - terminal: `make 파일명`
        
        
        - data-type과 fnc에 대한 정보가 들어있는 파일 불러와야 명령어 실행 가능(수업에서는 cs50.h 파일)
        - 복잡한 버전
            
            `clang -o 지정파일명 파일명.확장자 -l참조할파일명`
            
            ex) `clang -o hello hello.c -lcs50`
            
    
- **프로그램 실행**
    
    `폴더/파일명.확장자`  파일의 프로그램 실행
    
    ex) `./a.out`  
    
    .(현재 폴더) a.out(자동으로 만들어지는 파일명)
    
- **현재 폴더or디렉토리의 파일 리스트**
    
    `ls` 
    
    * 붙으면 머신 코드
    
- **파일 삭제**
    
    `rm 파일명.확장자`  →  (질문) `rm: remove refular file ‘파일.확장자` → `y` 입력  → 삭제
    
    ![Untitled](CS50%20b2df4b505bd148b3aaba41411f2e9b5b/Untitled%201.png)
    

- `cd`  (change directory) 작업 위치 변경
    
    `cd 폴더명` 지정 폴더로 이동
    
    `pwd`  현재 폴더 위치 알려줌
    
- **디버깅 시, 사용가능 코드** (cs50 에서 사용가능)
    
    
    - help50
        
        `help50 make 파일명`
        
        에러 내용 해석해줌
        
        - `help50 valgrind 속한파일/파일명`
            
            메모리와 관련한 문제 파악해줌
            
        
    - (cs50 IDE) debug50
        
        `debug50 파일명`
        
        오른쪽 패널을 통해 한 줄씩 코드 실행할 수 있음
        
        종료하려면 ctrl + c
        
    - check50
        
        `check50 cs50/problems/파일명`
        
        자동 검사 프로그램
        
    - style50
        
        `style50 파일명.확장자`
        
        코드가 심미적으로 잘 작성되었는지 검사
        
    

# 컴파일

make나 clang을 사용해서 프로그램을 실행할 때 거치는 단계

- make : c소스파일의 링크, 컴파일, 빌드 작업을 자동화해주는 툴

## 컴파일러

소스 코드를 머신 코드로 변환해주는 프로그램

- 소스 코드: 사용자가 직접 작성한 코드
- 머신 코드: 컴퓨터가 이해할 수 있는 이진수 코드

![Untitled](CS50%20b2df4b505bd148b3aaba41411f2e9b5b/Untitled%202.png)

## 1. **전처리(Precompile)**

- 전처리기에 의해 수행
- # 으로 시작되는 C 소스 코드는 전처리기에게 컴파일 실행 전, 실행 사항 전달
    
    ex) `#include <stdio.h>` : stdio.h 파일의 내용이 #include 부분에 포함
    

## 2. **컴파일(Compile)**

C 코드를 어셈블리어(저수준 프로그래밍 언어)로 변환

## 3. **어셈블(Assemble)**

- 어셈블리 코드를 오브젝트 코드(이진코드)로 변환
- 어셈블러라는 프로그램이 수행

## 4. **링크(Link)**

- 프로그램이 (math.h나 cs50.h와 같은 라이브러리를 포함해) 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 거치는 단계
- 링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐줌

# 배열

## 선언

`자료형 array[n];`

`자료형 array[n] = {el, el, …}`

값을 받아 배열에 저장 후, 평균 구하는 코드

```c
#include <cs50.h>
#include <stdio.h>

float average(int length, int array[]);

int main(void)
{
    // 사용자로부터 점수의 갯수 입력
    int n = get_int("Scores:  ");

    // 점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Score %i: ", i + 1);
    }

    // 평균 출력
    printf("Average: %.1f\n", average(n, scores));
}

//평균을 계산하는 함수
float average(int length, int array[])
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += array[i];
    }
    return (float) sum / (float) length;
}
```

# 알고리즘

## 실행시간

- **big O** (빅오) 표기법
    
    실행 시간의 상한(최악의 시간)을 표시
    
    - O(n^2) - 버블 정렬, 선택 정렬
    - O(n log n) - 병합 정렬
    - O(n) - 선형 검색
    - O(log n) - 이진 검색
    - O(1)
    
- **Big Ω** (빅 오메가) 표기법
    
    실행 시간의 하한(최선의 시간)을 표시
    
    - Ω(n^2) - 선택 정렬
    - Ω(n log n) - 병합 정렬
    - Ω(n) - 버블 정렬
    - Ω(log n)
    - Ω(1) - 선형 검색, 이진 검색
    
- ****Big-θ (빅 세타) 표기법****
    
    알고리즘 상한 = 하한이면 세타로 표기
    
    - θ(n^2) - 선택 정렬
    - θ(n log n) - 병합 정렬
    - θ(n)
    - θ(log n)
    - θ(1)
    

## 검색

- **선형 검색**
    
    앞/뒤부터 차례대로 검색
    
    - O(n) : 총 n번 검색하므로
    - Ω(1) : 운 좋아서 맨 앞에 있으면
    
- **이진 검색**
    
    중간값 확인 후, 작으면 → 왼쪽 검색/ 크면 → 오른쪽 검색
    
    (정렬 후에 사용 가능)
    
    - O(log n)
    - Ω(1) : 중간에 있으면

## 정렬

- **버블 정렬**
    
    두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식
    
    - O(n^2) : 비교&자리바꿈 n-1번 중첩으로 진행
    - Ω(n) : 정렬된 경우 n-1번 비교 후, 종료
    
- **선택 정렬**
    
    배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식
    
    - O(n^2) : n + (n-1) + (n-2) + … = n(n-1)/2
    - Ω(n^2) : 정렬 여부 상관없이 모두 실행
    
- **병합 정렬** (합병 정렬)
    
    원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬하는 방식
    
    나누고 나누고 나눔 → 왼쪽 부분 정렬 → 오른쪽 부분 정렬 (정렬은 선두의 숫자를 비교해서 작은 수를 올리는 방식)  → 합치기
    
    - O(n log n) / Ω(n log n)
    

## 조건문

조건문 맨 뒤에 성공이면 `return 0`(함수 종료)

실패면 `return 1` (0만 아니면 됨)

```jsx
int main(void)
{
    // numbers 배열 정의 및 값 입력
    int numbers[] = {4, 8, 15, 16, 23, 42};

    // 값 50 검색
    for (int i = 0; i < 6; i++)
    {
        if (numbers[i] == 50)
        {
            printf("Found\n");
            return 0;
        }
    }
    printf("Not found\n");
    return 1;
}
```

## struct (구조체)

여러가지 자료형을 담을 수 있는 구조

- 선언
    
    `typeof struct {자료형 이름} 구조체이름`
    
- 호출
    
    `구조체이름.이름([n])`  (배열이라면)
    

- 예시
    
    ```jsx
    typedef struct
    {
        string name;
        string number;
    }
    person;
    
    int main(void)
    {
        person people[4];
    
        people[0].name = "EMMA";
        people[0].number = "617–555–0100";
        people[1].name = "RODRIGO";
        people[1].number = "617–555–0101";
        people[2].name = "BRIAN";
        people[2].number = "617–555–0102";
        people[3].name = "DAVID";
        people[3].number = "617–555–0103";
    
        // EMMA 검색
        for (int i = 0; i < 4; i++)
        {
            if (strcmp(people[i].name, "EMMA") == 0)
            {
                printf("Found %s\n", people[i].number);
                return 0;
            }
        }
        printf("Not found\n");
        return 1;
    }
    ```
    

## 재귀(recursion)

함수가 본인 스스로를 호출하는 것

- 재귀 미사용
    
    ```jsx
    #include <cs50.h>
    #include <stdio.h>
    
    void draw(int h);
    
    int main(void)
    {
        // 사용자로부터 피라미드의 높이를 입력 받아 저장
        int height = get_int("Height: ");
    
        // 피라미드 그리기
        draw(height);
    }
    
    void draw(int h)
    {
        // 높이가 h인 피라미드 그리기
        for (int i = 1; i <= h; i++)
        {
            for (int j = 1; j <= i; j++) // 중첩 
            {
                printf("#");
            }
            printf("\n");
        }
    }
    ```
    

- 재귀 사용
    
    ```jsx
    void draw(int h)
    {
        // 높이가 0이라면 (그릴 필요가 없다면)
        if (h == 0)
        {
            return;
        }
    
        // 높이가 h-1인 피라미드 그리기
        draw(h - 1);
    
        // 피라미드에서 폭이 h인 한 층 그리기
        for (int i = 0; i < h; i++)
        {
            printf("#");
        }
        printf("\n");
    }
    ```
    
    내부적으로 호출하는 함수에서 h=0 일 때, 멈춰지는 조건문 추가해야 함
    

## 포인터

다른 값을 가리키는 화살표 변수

- 선행요소
    - `&변수` ⇒ 변수의 메모리상 주소 호출
    - `*메모리주소` ⇒  주소에 있는 실제값
    - 주소값 호출 시, `%p` 사용할 것 : 변수의 주소를 16진법으로 표현
    
    ```jsx
    #include <stdio.h>
    
    int main(void)
    {
        int n = 50;
        printf("%p\n", &n); // 0x7ffe00b3adbc 같은 메모리 주소 출력됨
    		printf("%i\n", *&n); // 50 출력 ( 주소값을 얻어 다시 그 값 출력이므로)
    }
    ```
    
- 선언
    
    `type *p = &n`
    
    - `*`은 변수가 포인터라는 의미
        
        (안 쓰면 경고 뜸 - 주소는 정수가 아니기 때문에 반드시 포인터에 저장해야 함)
        
    - `p`라는 변수에 n의 주소값을 저장
        
        (★ n을 가리키고 있는 화살표라고 보면 됨)
        
    - 반드시 메모리를 할당 후, 포인터를 선언할 것
        
        ```c
        int main(void)
        {
            int *x;
            int *y;
        
            x = malloc(sizeof(int));
        
            *x = 42;
            *y = 13; // 오류 발생 가능성
        }
        ```
        
        초기화 되지 않은 `*y`는 프로그램 어딘가를 임의로 가리키고 있을 수 있음 → 오류 발생 가능성 ↑
        

## 문자열

c언어에 string이라는 자료형이 없고, char과 포인터를 이용해서 표기

- 표현법
    
    `char *s = "string"`
    
    첫번째 문자(s[0])의 주소를 가리키는 포인터
    
    - 배열 형식으로 주소값이 하나씩 증가되며 연달아 저장, 인덱스로 접근 가능
        
        ![Untitled](CS50%20b2df4b505bd148b3aaba41411f2e9b5b/Untitled%203.png)
        
        ```c
        #include <stdio.h>
        
        int main(void)
        {
          char *s = "EMMA";
          printf("%p\n", &s); // "E"
        	printf("%p\n", &(s+1)); // "M"
        	printf("%p\n", &(s+2)); // "M"
        	printf("%p\n", &(s+3)); // "A"
        }
        ```
        
    - 문자열의 끝에는 `\0`(널 종단 문자)가 붙어있어서 끝을 인식 가능
        
        (`\0` : 모든 비트가 0인 1바이트임)
        
- 비교 방법
    - `*a == *b` 와 같이 안의 값 비교할 것
    - 포인터만 비교하면 값이 아니라 주소값을 비교해서 의도한 결과 못 얻음
    - 예시
        
        ```c
        int main(void)
        {
           char *a = get_string("s: ");
           char *b = get_string("s: ");
        
           if(*a == *b) { // 포인터 안의 값 비교
               printf("same\n");
               printf("%p\n",a); // 주소값 출력
               printf("%p\n",b);
           } 
            else {
                printf("different\n");
                printf("%p\n",a);
               printf("%p\n",b);
            }
        ```
        
        ![Untitled](CS50%20b2df4b505bd148b3aaba41411f2e9b5b/Untitled%204.png)
        
        `*s` 로 안에 값 비교하니까 주소는 달라도 같다고 나옴
        
    - 통째로 비교하는 함수 : `strcmp(str, str)` ⇒ 반환값 0 (일치) / -1 (불일치)
    
- 문자열 복사하기
    
    ```c
    char *s = "string";
    
    char *t = malloc(strlen(s) + 1); // 1. 메모리 할당
    
    for (int i = 0, n = strlen(s); i <= n; i++) {
    	t[i] = s[i]; // 2. 루프로 값 복사
    }
    
    // strcpy(t,s)
    ```
    
    1. 문자열의 길이 + 1 (널 종단 문자까지) 크기의 메모리 할당
        - 메모리 할당 함수 :
            
             `malloc(할당받을 메모리 크기)`
            
        - 문자열 길이 반환 함수 (string.h) : `strlen(str)`
    2. 루프로 char 하나하나 값 복사
        
        (string.h 라이브러리의 `strcpy(t,s)` 로 구현되어 있음)
        
    - 문자열을 받아 그대로 복사하면 주소값이 복사되기 때문에 값 수정 시, 원래 값도 변경됨
        
        ```c
        int main(void)
        {
            string s = get_int("s: "); // "emma"
            string t = s;
        
            t[0] = toupper(t[0]);
        
            printf("s: %s\n", s); // "Emma" s까지 수정됨
            printf("t: %s\n", t); // "Emma" 
        }
        ```
        

## 메모리 할당/해제

할당  `malloc(할당받을 메모리 크기)`

해제 `free(value)`

- 할당 후, 해제하지 않으면 메모리 누수 발생

- 버퍼 오버플로우가 생기는 경우
    
    ```c
    void f(void)
    {
        int *x = malloc(10 * sizeof(int));
        x[10] = 0; // 여기서 발생
    }
    
    int main(void)
    {
        f();
        return 0;
    }
    ```
    
    1. int ⇒ 4byte 이므로 총 `x` 에 40바이트 할당 (배열의 요소 당 4바이트씩)
    2. `x` ⇒ `x[0]` ~ `x[9]`
        
        ∴ `x[10]`은 존재하지 않기 때문에 오류
        

## 메모리 교환/ 스택/ 힙

- **메모리의 저장 구역**
    
    ![Untitled](CS50%20b2df4b505bd148b3aaba41411f2e9b5b/Untitled%205.png)
    
    1. machine code - 프로그램이 컴파일된 이진코드 저장
    2. globals - 프로그램 내에 저장된 전역 변수
    3. heap - malloc으로 할당된 데이터 저장
        
        (양이 많아질수록 아래로 내려옴)
        
    4. stack - 프로그램 내의 지역변수, 함수 저장

- 함수를 통한 교환
    - 실행 안되는 경우
        
        ```c
        void swap(int a, int b);
        
        int main(void)
        {
            int x = 1;
            int y = 2;
        
            printf("x: %i, y: %i\n", x, y); // x: 1, y: 2
            swap(x, y);
            printf("x: %i, y: %i\n", x, y); // x: 1, y: 2
        }
        
        void swap(int a, int b)
        {
            int tmp = a;
            a = b;
            b = tmp; // rkqtaks qkRnlrh akfrl Eoansdp 변경x
        }
        ```
        
        1. 함수의 인자로 값만 전달 ⇒ 값이 복제되어 인자에 저장
        2. x, y 와 a, b는 스택 안, 다른 위치에 저장 → swap() 실행 (a, b만 자기네들끼리 값 바꿈) → 메모리에서 삭제 됨
        3. x, y의 값은 변하지 않음
        
    - 올바른 변경
        
        ![Untitled](CS50%20b2df4b505bd148b3aaba41411f2e9b5b/Untitled%206.png)
        
        ```c
        void swap(int *a, int *b);
        
        int main(void)
        {
            int x = 1;
            int y = 2;
        
            printf("x: %i, y: %i\n", x, y);
            swap(&x, &y); // 1
            printf("x: %i, y: %i\n", x, y);
        }
        
        void swap(int *a, int *b) // 2
        {
            int tmp = *a; // 3
        		*a = *b;
            *b = tmp;
        }
        ```
        
        1. 인수로 주소값 전달
        2. *을 사용해서 인자로 포인터 받음 (두 메모리 위치 연결 시킴)
        3. 변경 함수도 포인터로 표기

## 값 받아 저장 구현

- 정수값 받아서 저장 ( = `get_int` (cs50))
    
    ```jsx
    #include <stdio.h>
    
    int main(void)
    {
        int x;
        printf("x: ");
        scanf("%i", &x); // 입력값 -> x의 주소에 저장
    }
    ```
    
- 문자열 받아서 저장 (= `get_string` (cs50))
    
    ```jsx
    #include <stdio.h>
    
    int main(void)
    {
        char s[문자열 길이];
        printf("s: ");
        scanf("%s", s);
    }
    ```
    

## 파일 쓰기

- 파일 만들기
    
    `FILE *pointer = fopen (파일명.확장자 모드)`
    
    FILE이라는 자료형으로 불러옴
    
    - 모드
        - `"r"` (read) 읽기 전용, 편집x
        - `"w"` (write)  편집 가능
        - `"a"` (append) 입력값 뒤로 추가
    
- 파일에 내용 출력
    
    `fprintf(파일명, "형식 지정자, 내용", 변수)`
    
- 파일 작업 종료
    
    `fclose(var-name)`
    

```c
#include <cs50.h>#include <stdio.h>#include <string.h>int main(void)
{
    FILE *file = fopen("phonebook.csv", "a"); 
		// phonbook 이라는 파일 생성 / "a" 라서 입력값 뒤로 추가됨
    char *name = get_string("Name: ");
    char *number = get_string("Number: ");

    fprintf(file, "%s,%s\n", name, number);
		// 입력값이 파일에 출력되어 내용이 추가됨

    fclose(file);
}
```

## 파일 읽기

```c
#include <stdio.h>

int main(int argc, char *argv[]) 
{
		// 에러 체크 : 입력값 있는지 확인 / 없다면 종료
    if (argc != 2) 
    {
        return 1; // 1 => 오류
    }
		
		// 파일 생성: 입력값 -> 파일명
    FILE *file = fopen(argv[1], "r"); 

		// *에러 체크
    if (file == NULL)  
    {
        return 1;
    }
 
		// 3개의 바이트 배열 만들기
   unsigned char bytes[3];

		// *파일 읽기
    fread(bytes, 3, 1, file);
		
		// *파일이 jpeg인지 확인 (16진법은 그냥 써도 됨)
    if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
    {
        printf("Maybe\n");
    }
    else
    {
        printf("No\n");
    }
    fclose(file);
}
```

- `fopen`, `malloc`, `get_string` 같은 함수는 에러 발생 시, `null` 반환

- 파일 읽기
    
    `fread(배열, 읽을 바이트 수, 읽을 횟수, 읽을 파일)`
    
    파일의 첫 지정 바이트를 읽음
    
    ex) `fread(bytes, 3, 1, file);` (위 코드)
    
    파일의 첫 24바이트를 읽어옴
    
- jpeg의 특징
    
    첫 세 바이트가 `0xff`, `0xd8`, `0xff` 임
    
    ∴ 이를 검사하면 jpeg 파일인지 알 수 있음
    
    (참고: c언어에서 16진법은 그냥 써도 됨)