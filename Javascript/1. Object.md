# Object

# object (객체)

- 서로 연관된 변수와 함수(method)를 그룹핑, 이름 붙인 것
- 개체의 특성에 대해 많은 property를 가진 요소
- 순서없이 저장하는 구조
- 다양한 데이터를 담을 수 있음
    
    (↔ 원시형(primitive type) : 하나의 데이터만 담기 가능)
    
- 문자형/ 심볼형

```jsx
const jwName = "jiwoo";
const jwHeight = 160;
const jwBirthday = 0804;
```

### 선언

- **빈 객체 선언**
    1. `var name = new Object();` '객체 생성자' 문법
    2. `var name = {};`  '객체 리터럴' 문법 (주로 씀)

- **객체값 선언**
    
    `var obj-name = {`
    
    `prop: value,` 
    
    `prop: value,`
    
    `};`
    
    - property (key) - 문자형/심볼형(아닌 경우 문자형으로 변형됨)
    - value - 모든 자료형 허용
    
    ```jsx
    const jw = {
    	name: "jiwoo",
    	height: 160,
    	birthday: 0804,
    }
    ```
    
    - 계산된 프로퍼티
        
        `[prop] : value`
        
        프로퍼티 이름을 동적으로 받아옴
        
        ```jsx
        let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");
        
        let bag = {
          [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아 옵니다.
        };
        
        alert( bag.apple ); // fruit에 "apple"이 할당되었다면, 5가 출력됩니다.
        ```
        
    
- **프로퍼티 값 단축 구문**
    
    변수 = key = value 이라면 `key: value` 단축
    
    ⇒ `key`
    
    ```jsx
    function makeUser(name, age) {
      return {
        name, // name: name 과 같음
        age,  // age: age 와 같음
        // ...
      };
    }
    ```
    

### 호출

`obj-name.prop`

= `obj-name[prop]` (조합된 키 or 동적인 값에 사용)

```jsx
console.log(jw.name);
console.log(jw['name']);

let a = 'name'
consloe.log(jw[a]); // 값 같음
```

### **수정/ 추가**

`object.prop = ~;`

= `object[prop] = ~;`

```jsx
const jw = {
	name: "jiwoo",
	height: 160,
	birthday: 0804,
}

console.log(jw.height); // 160

jw.height = 170;

console.log(jw.height); // 170 -> 값 변경
```

### 삭제

`delete obj-name.prop`

= `delete obj-name[prop]`

### prop 존재 여부 확인

1. `obj.key === undefined`
    
    존재하지 않는 프로퍼티 → `undefined` 반환
    
    - 값에 undefined가 할당된 경우에는 정확한 존재여부 확인이 불가능하니 아래 방법 사용
    
2. `"key" in obj-name`  
    
    존재 여부에 따라 boolean 반환
    

```jsx
let user = { name: "John", age: 30, height: undefined, };

alert(user.birth === undefined); // user.birth 존재x -> true 출력
alert(user.height === undefined); // 존재하지만 할당값 일치 -> true 출력

alert("age" in user); // user.age가 존재 -> true 출력
alert("birth" in user); // user.bl 존재x -> false가 출력

```

### for in 반복문

`for (var key in object) {~;}`

- 객체의 열거 가능한 prop을 순회
- 변수를 통해 key에 접근 (value에는 직접 접근 불가)
- 빈 obj ⇒  실행되지 않고 빠져나감
- 배열에는 되도록 사용X (느리고 적절하지 않음)
- 객체의 정렬순서는 추가순이 아님
    - 정수 prop - 자동 정렬 ([설명](https://ko.javascript.info/object))
    - 이외 propr - 추가한 순서대로 정렬
    

```jsx
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) { 
  alert( key );  // name, age, isAdmin 연거푸 실행
  alert( user[key] ); // John, 30, true
}
```

### 순회 관련 메소드

- map, set, array와 차이점
    - `obj.keys()` X ⇒ `Object.keys(obj)`  O
    - 이터러블 객체가 아닌 배열을 반환
- 심볼형 프로퍼티는 무시 (for in도 마찬가지)

1. `Object.keys(obj)`  객체의 키만 담은 배열 반환

1. `Object.values(obj)`  객체의 값만 담은 배열 반환

1. `Object.entried(obj-name)`  [key, value] 쌍을 담은 배열 반환
    - `Object.fromEntries(iterable)`
        
        `entried`의 반환값 (배열) → 객체로 변환 후, 반환
        

```jsx
let user = {
  name: "John",
  age: 30
};

Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]

// 값을 순회
for (let value of Object.values(user)) {
  alert(value); // Johnt과 30이 연속적으로 출력됨
}

// key와 value를 변수로 분해 할당하기
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, age:30이 차례대로 출력
}
```

### 주의사항

- **const는 수정이 불가능하지 않나요?**
    
    const가 아닌 안의 prop의 값을 수정하니까 가능
    
    obj인 player는 아직도 동일하다!
    

![https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_markup_images/26ad00c849fe490da9cb94bb82907b25/c163b785-a18c-4b50-a345-ee59df375625.png](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_markup_images/26ad00c849fe490da9cb94bb82907b25/c163b785-a18c-4b50-a345-ee59df375625.png)

![const 인 obj 값 수정 시 → 오류](https://slid-capture.s3.ap-northeast-2.amazonaws.com/public/capture_images/26ad00c849fe490da9cb94bb82907b25/fe8a6cd6-139c-4e13-b9fc-6a566089bc57.png)

const 인 obj 값 수정 시 → 오류

- **참조에 의해 저장·복사됨**
    
    다른 변수에 obj 할당 → 값 저장 X , 참조값(객체 저장된 메모리 주소) 저장
    
    : 원시값(문자열·숫자·불린)은 값 그대로 저장·할당·복사되는데 객체는 저장되어 있는 주소인 ‘참조값’이 저장됨. 고로 값이 저장된 위치는 똑같은데 열어볼 수 있는 키(할당 변수)가 늘어나는 셈.
    
    ![Untitled](Object%20c4ee2203cedb4656bc1991d2d55f0885/Untitled.png)
    
    ```jsx
    let user = { name: 'John' };
    
    let admin = user;
    
    admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경됨
    
    alert(user.name); // 'Pete' 출력
    ```
    

# 옵셔널 체이닝

`?.`을 사용해 프로퍼티가 없는 중첩 객체를 에러 없이 접근

- **필요한 이유**
    
    ```jsx
    let user = {};
    
    alert(user.address);  // undiefined 반환 (에러x)
    
    alert(user.address.number); // 에러 발생
    
    alert( user && user.address && user.address.number );
    // 이전에 에러를 막기 위해 쓰던 코드
    ```
    
    - obj.prop를 호출하는 것은 값이 없어도 문제 없지만, 중첩 객체부터는 에러가 발생
    - 전에는 에러를 막기 위해 아래같이 코드 작성
        
        `alert( user && user.address && user.address.number );`
        
        : 값 없다면 `undefined` 반환
        

- `?.`은 `?.`'앞’의 평가 대상이 `undefined`나 `null`이면 평가를 멈추고 `undefined`를 반환

```jsx
let obj = {
  age: {
    name: "jiwoo",
  },
};

alert(obj.age?.name); 
```

# 객체 분해

## 문법

### 기본 문법

`let {key1, key2} = {key1: …, key2: …}`

프로퍼티가 아닌 key이름으로 호출 가능해짐

- 프로퍼티 하나만 뽑아내기 가능
    
    ex) `let {key} = {key: …, key1: …}`
    

```jsx
let obj = {
	a : 100,
  b: 160
};

let {a, b} = obj;

alert(a);  // 100
alert(b);  // 160
```

### 다른 이름 변수 저장 (`:`)

`let {key1: var1, key2: var2} = {key1: …, key2: …}` 

key 이름이 아닌 다른 변수에 저장하기

```jsx
let obj = {
	a : 100,
  b: 160
};

let {a: A, b: B} = obj;

alert(A);  // 100
alert(B);  // 160
```

### 기본값 설정 (`=`)

`let {key1 = default, key2 = default} = {key1: …, key2: …}`

값이 없을 시, 기본값으로 호출

- 기본값으로 표현식, 함수 호출 할당 가능
- `:` 와 함께 사용 가능

```jsx
let obj = {
	a : 100
};

let {a = 200, b = prompt("number?")} = obj;

alert(a);  // 100
alert(b);  // prompt에 입력한 값

// : 과 함께 사용 -> 다른 변수에 할당 & 기본값 설정
let {a: A = 200, b: B = prompt("number?"} = obj;

alert(A);  // 100
alert(B);  // prompt에 입력한 값
```

### 나머지 할당 (`…`)

`let {key, …rest} = {key : …, key1: …, key2: …}`

`…`을 이용하여 나머지 객체 할당

```jsx
let obj = {
	a : 100,
	b : 200,
	c : 300
};
let {a, ...rest} = obj;

alert(a);  // 100
alert(rest);  // {b : 200, c : 300}
alert(rest.b); // 200
```

### 기존 변수에 재할당

재할당 시, 할당문을 괄호로 묶어줄 것

∵ 대괄호를 코드 블록으로 인식해서 에러가 뜨기 때문에 표현식으로 보이도록 괄호로 묶어줌 (완벽히 이해 못함..)

```jsx
let a, b, c; // 이미 선언

// 존재하던 변수에 할당하기
// 앞뒤에 괄호 없으면 에러남
({a, b, c} = {a: 100, b: 200});

alert( title ); // Menu
```

---

### 중첩 구조 분해

객체 안의 값이 다시 객체나 배열일 경우, 사용하는 패턴

- 객체 `let { obj: {key1, key2 …} }`
- 배열 `let { arr: [value1, value2] }`
    - `obj`와 `arr`의 전용 변수는 없음 (안의 정보에 변수 할당)
    
- 예시
    
    ```jsx
    let person = {
    	size: { // 객체
    		width: 27,
    		heigth: 160
    	},
    	name: ['kwak', 'jiwoo'] // 배열
    };
    
    // 중첩 구조 분해 사용
    let { size: {width, height},
    			name: [value1, value2] } = person;
    
    alert(width); // 27
    alert(value1); // kwak
    ```
    

### 함수의 인자에 적용하기

함수의 파라미터에 적용한다면 동적이고 똑똑해짐

```jsx
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width는 w에,
  height: h = 200, // height는 h에,
  items: [item1, item2] // items의 첫 번째 요소는 item1에, 두 번째 요소는 item2에 할당함
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
```

- 인자의 순서에 신경쓰지 않아도 됨
- 꼭 인수를 전달해야함 (안하면 에러)
    
    `fnc-name()`  X
    
    `fnc-name({})` O
    
    - 아예 에러 방지하려면
        
        `function fnc-name({ key1, key2…} **= {}**) {명령문}`
        
        인수 객체의 기본값을 빈 객체(`{}`)로 설정하기